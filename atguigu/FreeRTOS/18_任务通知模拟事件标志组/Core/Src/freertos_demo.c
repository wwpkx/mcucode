#include "freertos_demo.h"
/* freertos相关的头文件，必须的 */
#include "FreeRTOS.h"
#include "task.h"
/* 需要用到的其他头文件 */
#include "LED.h"
#include "Key.h"

/* 启动任务的配置 */
#define START_TASK_STACK 128
#define START_TASK_PRIORITY 1
TaskHandle_t start_task_handle;
void start_task(void *pvParameters);

/* 任务1的配置 */
#define TASK1_STACK 128
#define TASK1_PRIORITY 2
TaskHandle_t task1_handle;
void task1(void *pvParameters);

/* 任务2的配置 */
#define TASK2_STACK 128
#define TASK2_PRIORITY 3
TaskHandle_t task2_handle;
void task2(void *pvParameters);

/**
 * @description: 启动FreeRTOS
 * @return {*}
 */
void freertos_start(void)
{
    /* 1.创建一个启动任务 */
    xTaskCreate((TaskFunction_t)start_task,               // 任务函数的地址
                (char *)"start_task",                     // 任务名字符串
                (configSTACK_DEPTH_TYPE)START_TASK_STACK, // 任务栈大小，默认最小128，单位4字节
                (void *)NULL,                             // 传递给任务的参数
                (UBaseType_t)START_TASK_PRIORITY,         // 任务的优先级
                (TaskHandle_t *)&start_task_handle);      // 任务句柄的地址

    /* 2.启动调度器:会自动创建空闲任务 */
    vTaskStartScheduler();
}

/**
 * @description: 启动任务：用来创建其他Task
 * @param {void} *pvParameters
 * @return {*}
 */
void start_task(void *pvParameters)
{
    /* 进入临界区:保护临界区里的代码不会被打断 */
    taskENTER_CRITICAL();

    /* 创建3个任务 */
    xTaskCreate((TaskFunction_t)task1,
                (char *)"task1",
                (configSTACK_DEPTH_TYPE)TASK1_STACK,
                (void *)NULL,
                (UBaseType_t)TASK1_PRIORITY,
                (TaskHandle_t *)&task1_handle);
    xTaskCreate((TaskFunction_t)task2,
                (char *)"task2",
                (configSTACK_DEPTH_TYPE)TASK2_STACK,
                (void *)NULL,
                (UBaseType_t)TASK2_PRIORITY,
                (TaskHandle_t *)&task2_handle);

    /* 启动任务只需要执行一次即可，用完就删除自己 */
    vTaskDelete(NULL);

    /* 退出临界区 */
    taskEXIT_CRITICAL();
}

/**
 * @description: 任务一：用于按键扫描，当检测到按键KEY1被按下时，将发送任务通知。
 * @param {void} *pvParameters
 * @return {*}
 */
#define EVENTBIT_0 (1 << 0)
#define EVENTBIT_1 (1 << 1)
void task1(void *pvParameters)
{
    uint8_t key = 0;
    BaseType_t res = 0;
    while (1)
    {
        key = Key_Detect();
        if (key == KEY1_PRESS)
        {
            /* 发送任务通知 */
            res = xTaskNotify(
                task2_handle, // 接收方的任务句柄
                EVENTBIT_0,   // 要发送的通知值: 需要置位的bit置1
                eSetBits      // 写入的行为：设置bit位
            );

            if (res == pdPASS)
            {
                printf("KEY1按下，设置bit0为1..\r\n");
            }
        }
        else if (key == KEY2_PRESS)
        {
            /* 发送任务通知 */
            res = xTaskNotify(
                task2_handle, // 接收方的任务句柄
                EVENTBIT_1,   // 要发送的通知值: 需要置位的bit置1
                eSetBits      // 写入的行为：设置bit位
            );

            if (res == pdPASS)
            {
                printf("KEY2按下，设置bit1为1..\r\n");
            }
        }
        vTaskDelay(500);
    }
}

/**
 * @description: 任务二：用于接收任务通知，并打印相关提示信息。
 * @param {void} *pvParameters
 * @return {*}
 */
void task2(void *pvParameters)
{
    uint32_t notify_value = 0;
    uint32_t expect_value = 0;
    BaseType_t res = 0;
    while (1)
    {
        printf("task2运行...\r\n");

        res = xTaskNotifyWait(
            0x00000000,    // 接收通知前是否清理通知值，全0，表示32bit的都是0，都不清理
            0xffffffff,    // 接收到通知值后，是否清理通知值， 全1，表示32bit都是1，都要清零
            &notify_value, // 用来保存读取到的通知值
            portMAX_DELAY);
        if (notify_value & EVENTBIT_0)
        {
            /* bit0 = 1 */
            printf("接收到的bit0=1\r\n");
            expect_value |= EVENTBIT_0;
        }
        if (notify_value & EVENTBIT_1)
        {
            /* bit1 = 1 */
            printf("接收到的bit1=1\r\n");
            expect_value |= EVENTBIT_1;
        }

        /* 判断，是否希望的bit位都是1，如果是，则进行***处理 */
        if(expect_value == 3)
        {
            printf("期望条件满足，值=%d\r\n",expect_value);
        }

        vTaskDelay(500);
    }
}
